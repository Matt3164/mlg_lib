#AUTOGENERATED! DO NOT EDIT! File to edit: dev/10_ml_utils.ipynb (unless otherwise specified).

__all__ = ['LambdaRow', 'TrainingOutput', 'sk_train', 'make_single_feature_model', 'PatchTransform']

#Cell

from typing import Callable

import numpy as np
from numpy.core._multiarray_umath import ndarray
from sklearn.base import TransformerMixin, BaseEstimator


class LambdaRow(TransformerMixin, BaseEstimator):
    """

    Apply a function on each row of the numpy array

    """

    def __init__(self,
                 row_func: Callable[[ndarray], ndarray],
                 to_features: bool = False,
                 **kwargs):
        """Constructor for LambdaRow"""
        self.func = row_func
        self.func_kwargs = kwargs
        self.to_features = to_features

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        _arr = np.array([self.func(x, **self.func_kwargs) for x in X])
        if len(_arr.shape)>=2:
            if self.to_features:
                N = _arr.shape[0]
                return _arr.reshape(N,-1)
            else:
                return _arr
        else:
            return _arr.reshape(-1,1)

    def fit_transform(self, X, y=None, **fit_params):
        return self.fit(X).transform(X)

    def get_params(self, deep=True):
        return dict(list(self.func_kwargs.items())+[("row_func", self.func)])

    def set_params(self, **params):
        # params.pop("row_func")
        self.func_kwargs.update(params)
        return self

#Cell


import attr
from sklearn.pipeline import Pipeline
from typing import Callable, Dict, Any

@attr.s
class TrainingOutput(object):

    model = attr.ib(type=Pipeline)
    metrics = attr.ib(type=Dict[str, Any])


#Cell

import numpy as np
from typing import Callable, Dict, Any
from sklearn.pipeline import Pipeline

def sk_train(
    xtrain: np.ndarray,
    xtest: np.ndarray,
    ytrain: np.ndarray,
    ytest: np.ndarray,
    model: Pipeline,
    metrics: Dict[str, Callable[[np.ndarray, np.ndarray], Any]]
    )->TrainingOutput:

    model.fit(xtrain, ytrain)

    computed_metrics = dict()

    for tag, (x,y) in [("train", (xtrain, ytrain) ), ("test", (xtest, ytest))]:
        predictions = model.predict(x)

        for metric_tag, metric_fn in metrics:
            computed_metrics["_".join([tag, metric_tag])] = metric_fn(y, predictions)

    return TrainingOutput(
        model=model,
        metrics=computed_metrics
    )


#Cell

from sklearn.pipeline import Pipeline, make_pipeline

def make_single_feature_model(
    feature_fn: Callable[[np.ndarray], np.ndarray],
    clf: Pipeline
    )->Pipeline:

    return make_pipeline(
        LambdaRow(feature_fn),
        clf
    )

#Cell

import numpy as np
from skimage.util import view_as_windows
from sklearn.base import TransformerMixin, BaseEstimator
from sklearn.feature_extraction.image import PatchExtractor


class PatchTransform(TransformerMixin, BaseEstimator):
    """"""

    def __init__(self, transformer: BaseEstimator,
                 patch_size: int,
                 max_patches: int,
                 stride: int):
        """Constructor for ProbFromClf"""
        self.transformer = transformer
        self.patch_size = patch_size
        self.max_patches = max_patches
        self.stride = stride


    def fit(self, X, y=None):
        extractor = PatchExtractor(patch_size=(self.patch_size, self.patch_size), max_patches=self.max_patches)

        patch_X = extractor.transform(X)

        n_patches, _, _, = patch_X.shape

        self.transformer.fit(patch_X.reshape(n_patches, -1))

        return self

    def _extract_patch(self, arr):
        win_arr = view_as_windows(arr, window_shape=self.patch_size, step=self.stride)

        n_patches_i, n_patches_j, _, _ = win_arr.shape

        return self.transformer.transform(win_arr.reshape(n_patches_i * n_patches_j, -1)).flatten()

    def transform(self, X):
        return np.array([self._extract_patch(x) for x in X])

    def get_params(self, deep=True):
        return dict(transformer=self.transformer,
                    stride=self.stride,
                    patch_size=self.patch_size,
                    max_patches=self.max_patches)

    def set_params(self, **params):

        self.max_patches = params["max_patches"]
        self.stride = params["stride"]
        self.patch_size = params["patch_size"]

        params.pop("max_patches")
        params.pop("stride")
        params.pop("patch_size")

        new_kwargs = dict()

        for key in params.keys():
            if "transformer" in key:
                new_kwargs[key[len("transformer__"):]]=params[key]

        return self.transformer.set_params(**new_kwargs)